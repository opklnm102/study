# [Web] REST API





<br>

## REST API Example
| URI | description |
|:--|:--|
| /tickets | POST - new ticket 생성<br>GET - 모든 ticket 조회<br>PUT - Bulk update of tickets<br>DELETE - 모든 ticket 제거 |
| /tickets/2 | POST - not used<br>GET - id=2 ticket 상세 정보 조회<br>PUT - d=2 ticket 수정<br>DELETE - id=2 ticket 제거 |
| /tickets/2/messages | POST - id=2 ticket의 message 생성<br>GET - id=2 ticket의 모든 message 조회<br>PUT - id=2 ticket의 message Bulk update<br>DELETE - id=2 ticket의 모든 message 제거 |


<br>

## API versioning strategies
* 시간이 지남에 따라 API는 발전하므로 버전 관리 전략을 마련하는게 중요
* 좋은 버전 관리 전략은 API 변경으로 기존 client가 중단되지 않고 하나 이상의 버전이 항상 예정대로 동작하도록 보장한다
* URI의 version number와 header의 날짜 기반 하위 버전을 사용하는 혼합 방식을 사용할 수도 있다

| Strategy | description |
|:--|:--|
| URI Versioning | 가장 일반적인 전략으로 URI에 version number를 포함하는 것<br>e.g. /api/v1/users, /api/v2/users |
| Custom Headers Versioning | custom HTTP request header 사용<br>`Accept-version: v1` header를 사용하여 사용 중인 API version 지정 |
| Query Parameter Versioning | query parameters 사용<br>e.g. /api/users?version=1 |
| Content Negotiation | 버전마다 custom media type 정의<br>client는 `Accept: application/api-v3+json` 같이 적절한 media type을 포함하여 사용하려는 버전을 지정 |


<br>

## Result filtering, sorting, searching

### filtering
* 결과를 필터링하여 결과의 범위를 좁히거나 Drill down하는데 사용
```
GET /tickets?state=open
GET /tickets?state=open&category=1,2,3
```

<br>

### sorting
```
GET /tickets?sort=-priority - 우선 순위 내림차순 정렬
GET /tickets?sort=-priority,created_at - 우선 순위는 내림차순, 같은 우선 순위 내에서는 오름차순(오래된 순서)로 정렬
```
* 더 쾌적한 API를 제공하기 위해 특정 조건 집합에 쉽게 접근할 수 있는 alias 제공
  * GET /tickets/recently_closed

<br>

### searching
* Elasticsearch 같은 검색 엔진에 query가 필요하고, 결과는 위 API와 동일해야할 경우
```
GET /tickets?q=return&state=open&sort=-priority
```

<br>

### limit fields
* 항상 전체 리소스가 필요한 것은 아니다, 필요한 필드를 선택하도록하여 network traffic을 최소화하여 API 속도를 높이도록할 수 있다
* 포함할 필드의 목록을 쉼표로 구분
```
GET /tickets?fields=id,subject,updated_at&state=open&sort=-updated_at
```


<br>

## creation, update시 리소스 반환
* POST, PUT, PATCH API 호출시 파라미터에 포함되지 않은 기본 필드(e.g. created_at 등)를 수정할 수 있다
* client가 API를 다시 호출하지 않고 업데이트된 필드를 얻을 수 있게 응답에 생성/수정된 리소스를 반환
* POST의 경우 HTTP 201 status code + location header로 생성된 리소스를 표현

<br>

## 필요시 리소스를 wrapping
* 모든 API를 아래와 같이 wrapping할 필요는 없다
```json
{
  "data": {
    "id": 123,
    "name": "John"
  }
}
```









——————————————————————
## Different API Authentication Methods

1. Basic Auth
2.  API Keys
3.  OAuth 2.0
4.  JSON Web Tokens
5.  Header API Authentication

### 1 Basic Auth
It is the simplest form of API authentication that uses a username and password to access the API.
However, it is not secure, as the username and password are sent in plain text.

### 2 API Keys

They are unique keys generated by the API provider to authenticate and authorize API requests.

It is easy to implement but can be compromised if shared or intercepted.

### 3 OAuth 2.0

A protocol that enables delegated access to resources without sharing credentials.

It uses tokens that expire and are refreshed after a certain period, providing better security.

### 4 JSON Web Tokens

It is a standard for creating secure access tokens that can be used for authentication and authorization.

It is self-contained and can carry information about the user, reducing the need for frequent database lookups.


### 5 Header API Authentication

Header authentication lets API providers require API consumers to add one or more authentication-related headers to API requests.



TODO: Authentication, Caching, Errors
https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#advanced-queries












[PUT - HTTP Specification](https://www.rfc-editor.org/rfc/rfc9110.html#name-put)

upsert API -> PUT은 new or update이므로 upsert API로 해도 된다!
멱등성을 보장해야하기 때문!

POST는 멱등성이 보장되지 않는다
-> POST API 호출시마다 새로운 리소스가 생기기 때문

그러나 PUT은 PUT /customers/2 이므로 id=2 customer에 대해서만 동작하므로 멱등성이 보장된다


그러나 REST API에서는 수정만을 담당하도록 구현

1. 부모 URL에 GET을 보내 key list 조회
GET /resources

2. 조회한 key 제거
DELETE /resources/k1

3. PUT으로 교체 추가
PUT /resources/k2





---------------------------------------------------
external ID 기반으로 resource를 생성하거나 존재한다면 update
    지정된 값이 존재하지 않으면 새 resource 생성
    해당 값을 가진 resource가 있으면 request body의 field 값으로 update

### upsert new resource
PATCH /resources/111
{
  "name": "Mike",
  "age": 20
}

## upsert exist resource
sobjects/Account/customExtIdField__c/11999 
-H "Authorization: Bearer token" 
-H "Content-Type: application/json" 
-d @updates.json 
-X PATCH


HTTP 204 No Content


보유한 resource count와 asynchronous에 따라 다르다
Bulk API가 가장 효울적




RESTful API, bulk
단일 resource 작업시 훌율한 제품이지만 1000개의 resource를 제어할 경우 어떻게 되는가?


POST
    여러 자원을 1번에 create, update, delete 할 수 있다
PUT
    요청을 list로 보내고 payload가 항목 목록을 정의하면 일괄 작업 가능
PATCH
    여러 리소스를 1번에 변경하거나
    리소스를 부분 update할 경우 사용


bulk processing
동일한 작업을 여러 항목에 적용

batch processing
다양한 작업을 다양한 항목에 적용

POST /v1/customers
GET /v1/customers/:id
PUT /v1/customers/:id
DELETE /v1/customers/:id
GET /v1/customers



여러 고객을 동시에 처리할 때 여러번 호출해야 한다

network I/O overhead로 인해
더 적은 데이터로 여러번 요청하는 것보다 더 많은 데이터로 더 적은 요청을 하는 것이 좋다



Google Drive 
복잡하지만 유연한 batch endpoint 구현
여러 리소스를 허용하는 endpoint 대신 여러 request를 처리하는 endpoint가 존재
meta HTTP 요청



ZenDesk
리소스 유형마다 batch endpoint가 존재

POST /api/v2/users/create_or_update_many.json
{
  "users": [
    {
      "name": "Roger Wilco",
      "email": "roge@example.org",
      "role": "agent"
    }, 
    {
      "external_id": "account_54321",
      "name": "Woger Rilco",
      "email": "woge@example.org",
      "role": "admin"
    }
  ]
}

단점
여러 사용자, 조직, 티켓등을 동시에 만들려면 3개의 network 호출 필요



batch, bulk endpoint 구현시 고려 사항
Error handling
    batch request 실패시 어떻게 할지?
    all or nothing인지 가능한 많은 요청을 처리해야하는지
 
Limiting of batch sizes
  특정 시간내에 endpoint를 호출할 수 있는 rate limit 설정







GET /event
[
    {
        "id": 1,
        "name": "xxx"
    },
    {
        "id": 2,
        "name": "yyy"
    }
]

GET /event/:id
{
    "id": 1,
    "name": "xxx"
}

POST /event
{
    "name": "xxx"
}

// Response
1
or
{
    "id": 1,
    "name": "xxx"
}

POST /event
[
    {
        "name": "xxx"
    },
    {
        "name": "yyy"
    }
]

// Response
[1, 2]






<br><br>

> #### Reference


> * [In REST is POST or PUT best suited for upsert operation? - Stackoverflow](https://stackoverflow.com/questions/18470588/in-rest-is-post-or-put-best-suited-for-upsert-operation)
> * [Insert or Update(Upsert) a Record Using an External ID - Salesforce REST API Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/dome_upsert.htm)
> * [Adding batch or bulk endpoints to your REST API](https://www.codementor.io/blog/batch-endpoints-6olbjay1hd)
> * [Batch: An API to bundle multiple REST operations](https://medium.com/paypal-engineering/batch-an-api-to-bundle-multiple-paypal-rest-operations-6af6006e002)


> * [REST API Sorting Paging and Filtering](https://www.thrinacia.com/blog/post/rest-api-sorting-paging-and-filtering)
> * [Best Practices for Designing a Pragmatic RESTful API](http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#advanced-queries)





Design Effective & Safe APIs


| | Bad | Good |
|:--|:--|:--|
| Use resource names | GET /querycarts/123 | GET /**carts**/123 |
| Use plurals | GET /cart/123 | GET /cart**s**/123 |
| Idempotency | POST /carts | POST /carts **{requetId: 1234}** |
| Use versioning | GET /carts/v1/123 | GET /**v1**/carts/123 |
| Query after soft deletion | GET /carts | GET /carts?**includeDeleted=true** |
| Pagination | GET /carts | GET /carts?**pageSize=xx&pageNo=xx** |
| Sorting | GET /items | GET /items?**sort_by=time** |
| Filtering | GET /items| GET /items?**filter=color:red**|
| Secure Access | X-API-KEY=xxx | X-API-KEY=xxx<br>X-EXPIRY=xxx<br>X-REQUEST-SIGNATURE=**hmac(URL + query string + expiry + body)**|
| Resource cross reference | GET /carts/123?item=321 | GET /carts/123/**items/321** |
| Add an item to a cart | POST /carts/123?addItem=321 | POST /carts/123/**items** {itemId: "items/321" } |
| Rate limit | No rate limit - DDos | Design rate limiting rules based on **IP**, **user**, **action group** etc|


